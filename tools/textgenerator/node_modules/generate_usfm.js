var fs = require('fs'),
	path = require('path'),
	bibleData = require('bible_data'),
	bibleFormatter = require('bible_formatter'),
	usfmParser = require('usfm_parser'),
	readline = require('readline');
	stream = require('stream'),
	verseIndexer = require('verse_indexer');

function generate(inputBasePath, outputBasePath, indexOutputPath, info, createIndex) {
	var breakChar = '\n';
	
	var 
		unparsedUsfmFlags = [],
		bookCodes = [],
		bookNames = [],
		bookAbbreviations = [],
		chapterList = [],
		chapterData = [],
		indexData = {},
		
		skipAheadKeys = ['','add','add*','wj','wj*', 'x', 'x*', 'f', 'f*', 'qs', 'ft', 'bk', 'fqa'];
	
	var usfmFiles = fs.readdirSync(inputBasePath);
	
	
	usfmFiles.forEach(function(filename) {
		
		if (filename.indexOf('.usfm') == -1) {
			return;
		}

		var filePath = path.join(inputBasePath, filename),
			data = fs.readFileSync(filePath, 'utf8'),
			lines = data.split('\n');
		
		//console.log(filePath, lines.length);
		
		var bookName = '',
			bookAbbr = '';
		
		var 
			currentBookInfo = null,
			currentChapterNum = null,
			currentVerseNum = '',
			currentChapterHtml = '',
			currentChapterCode = '',
			paragraphIsOpen = false,
			currentVerseCode = null,
			quoteIsOpen = false,
			verseIsOpen = false,
			currentHeader = '',
			currentVerseText = ''
			;
			
		for (var i=0,il=lines.length; i<il; i++) {
			var line = lines[i],
				usfm = usfmParser.parseLine(line);
			
			if (usfm == null) {
				return;			
			}
			
				
			// check the next line
			if (skipAheadKeys.indexOf(usfm.key) == -1 ) {
				
				var nextLineIndex = i+1;
				while (nextLineIndex < lines.length) {
					
					var nextLine = lines[nextLineIndex],
						nextUsfm = usfmParser.parseLine(nextLine);				
	
					if (skipAheadKeys.indexOf(nextUsfm.key) > -1 ) {
						usfm.text += ' ' + nextLine;
					} else if (nextUsfm == null ) {
						usfm.text += ' ' + nextLine;						
					} else {
						break;
					}
					nextLineIndex++;	
				}
			} else {
				// skip these
				continue;
				
			}
			
			
			switch (usfm.key) {
				default:
					// store all the flags we can use
					if (unparsedUsfmFlags.indexOf(usfm.key) == -1) {
						unparsedUsfmFlags.push(usfm.key);
					}
				
					// do nothing?
					break;
					
				case 'ide':
					// assume usfm
					break;
			
				case 'id':
					// get book info
					var bookId = usfm.text.split(' ')[0];
					currentBookInfo = bibleData.getBookInfoByUsfmCode(bookId.toUpperCase());
					
					bookCodes.push(currentBookInfo.dbsCode);
					//console.log('book', currentBookInfo != null ? currentBookInfo.names.eng[0] : 'NULL: ' + bookId);
					break;
				
				// intro stuff
				case 'is':	
				case 'ip':	
				case 'ili':	
				case 'ili2':								
				
				// headings
				case 'mt':
				case 'mt1':
				case 'mt2':
				case 'mt3':				
				case 'ms':
				case 'd':				
				case 'sp':
				case 'sr':
				case 'r':				
								
					if (verseIsOpen) {
						currentChapterHtml += '</span>' + breakChar;						
						verseIsOpen = false;
					}
					
					if (paragraphIsOpen) {
						currentChapterHtml += '</div>' + breakChar;						
						paragraphIsOpen = false;
					}	
		
					currentChapterHtml += '<div class="' + usfm.key + '">' + usfmParser.formatText(usfm.text) + '</div>' + breakChar;
			
														
				
					break;
					
				case 'b':
				
					if (verseIsOpen) {
						currentChapterHtml += '</span>' + breakChar;						
						verseIsOpen = false;
					}
					
					if (paragraphIsOpen) {
						currentChapterHtml += '</div>' + breakChar;						
						paragraphIsOpen = false;
					}	
					currentChapterHtml += '<div class="b">&nbsp;</div>' + breakChar;
														
				
					break;
					
				// TEXT BLOCKS
				case 'cp':
				case 'nb':
				case 'm':
				case 'mi':
				case 'pi':
				case 'li':
				case 'li1':	
				case 'li2':					
					// letting this fall through for now.
					
				case 'p':
					if (verseIsOpen) {
						currentChapterHtml += '</span>' + breakChar;						
						verseIsOpen = false;
					}				
				
					if (paragraphIsOpen) {
						currentChapterHtml += '</div>' + breakChar;						
						paragraphIsOpen = false;
					}				
				
					currentChapterHtml += '<div class="' + usfm.key + '">' + breakChar;
					paragraphIsOpen = true;
					
					if (usfm.text != '') {
						currentChapterHtml += '<span class="v ' + currentVerseCode + '" data-id="' + currentVerseCode + '">' + usfmParser.formatText(usfm.text);				
						verseIsOpen = true;
						
						currentVerseText += usfmParser.plainText(usfm.text);
					}
					
					break;
	
				case 'c':
					// new chapter
					if (usfm.number > 1) {
						
						
						if (verseIsOpen) {
							currentChapterHtml += '</span>' + breakChar;						
							verseIsOpen = false;
						}		
						if (paragraphIsOpen || quoteIsOpen) {
							currentChapterHtml += '</div>' + breakChar;						
							paragraphIsOpen = false;
							quoteIsOpen = false;
						}													
						
						
						// finish previous chapter
						chapterData.push({
							id: currentChapterCode,
							html: currentChapterHtml							
						});
						currentChapterHtml = '';
						paragraphIsOpen = false;
						quoteIsOpen = false;						
						verseIsOpen = false;
						chapterList.push(currentChapterCode);				
					}
					
					currentChapterNum = usfm.number;
					currentChapterCode = bibleFormatter.formatChapterCode(currentBookInfo.dbsCode, currentChapterNum);					
					currentChapterHtml += '<div class="c">' + 
												(currentBookInfo.dbsCode == 'PS' ? 
													(currentHeader.substring(currentHeader.length-1) == 's' ? currentHeader.substring(0,currentHeader.length-1) : currentHeader) + ' ' : ''
												) + usfm.number.toString() + 
										'</div>' + breakChar;
					
					break;
	
				case 'v':
					if (verseIsOpen) {
						currentChapterHtml += '</span>' + breakChar;						
						verseIsOpen = false;
					}
					
					// handle index						
					if (createIndex && currentVerseText != '' && currentVerseCode != null) {
						verseIndexer.indexVerse(indexOutputPath, currentVerseCode, currentVerseText, indexData);
					}
					// restart
					currentVerseText = usfmParser.plainText(usfm.text);
					
								
				
					// start new verse
					currentVerseNum = usfm.number;
					
					if (!currentVerseNum || !currentChapterNum) {
						console.log('ERROR with verse:', i, currentChapterCode);
						console.log( usfm );
						return;
					}
					
					currentVerseCode = bibleFormatter.formatVerseCode(currentBookInfo.dbsCode, currentChapterNum, currentVerseNum);
					
					currentChapterHtml += 
										'<span class="v-num v-' + currentVerseNum + '">' + currentVerseNum + '&nbsp;</span>' + 
										'<span class="v ' + currentVerseCode + '" data-id="' + currentVerseCode + '">' + usfmParser.formatText(usfm.text);
										
					
					verseIsOpen = true;
					
					break;
				case '':
					
					// ignore b/c we use a peak ahead function
				
					//currentChapterHtml += usfmParser.formatText(usfm.text);
					break;
					
				case 'q':
					// continue
				case 'q1':
				case 'q2':
				case 'q3':
				
					if (verseIsOpen) {
						currentChapterHtml += '</span>' + breakChar;						
						verseIsOpen = false;
					}				
				
					if (quoteIsOpen) {
						currentChapterHtml += '</div>' + breakChar;						
						quoteIsOpen = false;
					}				
				
					currentChapterHtml += '<div class="' + usfm.key + '">' + breakChar;
					quoteIsOpen = true;
					
					if (usfm.text != '') {
						currentChapterHtml += '<span class="v ' + currentVerseCode + '" data-id="' + currentVerseCode + '">' + usfmParser.formatText(usfm.text);
						
						currentVerseText += usfmParser.plainText(usfm.text);				
						verseIsOpen = true;
					}
					
				
					break;
				
				case 'h':	
					currentHeader = usfm.text.trim();
					break;
				case 'toc1':
					if (usfm.text.trim() != '') {
						bookName =  usfm.text.trim() ;
					}
					break;				
				case 'toc2':
					break;				
				case 'toc3':
					if (usfm.text.trim() != '') {
						bookAbbr = usfm.text.trim() ;
					}
					// TODO: add to book names and 
					break;
								
				
				
			}	
			
			/*
			if (currentVerseCode == 'PS1_2') {
				console.log('PS1_2', usfm.key, usfm.text);
				console.log( usfmParser.formatText(usfm.text) );
				
			}
			*/		
		}
		
		// last index
		if (createIndex && currentVerseText != '' && currentVerseCode != null) {
			verseIndexer.indexVerse(indexOutputPath, currentVerseCode, currentVerseText, indexData);
		}	
		
		
		// final closing tags
		if (verseIsOpen) {
			currentChapterHtml += '</span>' + breakChar;						
			verseIsOpen = false;
		}		
		if (paragraphIsOpen || quoteIsOpen) {
			currentChapterHtml += '</div>' + breakChar;						
			paragraphIsOpen = false;
			quoteIsOpen = false;
		}													
		
		if (bookName != '') {
			bookNames.push(bookName);
		} else {
			bookNames.push(currentbookInfo.names.eng[0]);
		}
		if (bookAbbr != '') {
			bookAbbreviations.push(bookAbbr);
		} else {
			bookAbbreviations.push(currentBookInfo.names.eng[0].replace(/\s/gi,'').substring(0,3) );
		}		
		
		
			
		// add final html			
		chapterData.push({
			id: currentChapterCode,
			html: currentChapterHtml							
		});		
		chapterList.push(currentChapterCode);		
				
	});
	
	console.log('chapters:', chapterData.length);
	
	// spit out codes
	for (var i=0, il=chapterData.length; i<il; i++) {
		var chapter = chapterData[i],
			previd = (i==0) ? null : chapterData[i-1].id,
			nextid = (i==il-1) ? null : chapterData[i+1].id,
			outputFilePath = path.join(outputBasePath, chapter.id + '.html'),
			html = 
				'<!DOCTYPE html>' + 
				'<html><head><meta charset="UTF-8" /><title>' + chapter.id + '</title></head>' + 
				'<body>' + 
					'<div id="nav"><span><a class="prev" href="' + previd + '.html">&#9664;</a><a class="home" href="../../../mobile.html#' + info.id + '">&#9776;</a><a class="next" href="' + nextid + '.html">&#9654;</a></span></div> ' +
					'<div class="section chapter ' + info['id'] + ' ' + chapter.id + ' ' + chapter.id.substring(0,2) + ' ' + info['lang'] + '" data-id="' + chapter.id + '" data-nextid="' + nextid + '" data-previd="' + previd + '" dir="' + info['dir'] + '" lang="' + info['lang'] + '">' + breakChar +
					chapter.html + breakChar + 
					'</div>' + breakChar +
				'</body>' + breakChar +
				'</html>'
			;
			
		fs.writeFileSync(outputFilePath, html, 'utf8');		
	}
	
	
	// spit out info
	info.type = 'bible';
	info.divisions = bookCodes;
	info.divisionNames = bookNames;
	info.divisionAbbreviations = bookAbbreviations;
	info.sections = chapterList;
	
	fs.writeFileSync(path.join(outputBasePath, 'info.json'), JSON.stringify(info), 'utf8');		
	
	// INDEX!	
	if (createIndex) {
		verseIndexer.createIndexFiles(indexOutputPath, indexData);
	}	
	
	console.log('unparsed', unparsedUsfmFlags);
		
}

module.exports = {
	generate: generate
}