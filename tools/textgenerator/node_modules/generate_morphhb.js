var fs = require('fs'),
	path = require('path'),
	$ = require('jQuery'),
	bibleData = require('bible_data'),
	bibleFormatter = require('bible_formatter'),
	verseIndexer = require('verse_indexer');

function generate(inputPath, outputPath, indexOutputPath, info, createIndex) {
	
	var 
		indexData = {},
		lemmaIndexData = {},
		lemmaIndexOutputPath = indexOutputPath.replace('index','indexlemma'),
		BOOK_LIST = ['RT'],
		breakChar = '\n';
			
	BOOK_LIST = bibleData.OT_BOOKS;

	// copy 
	var files = ['about.html']; // , 'info.json'];
	files.forEach(function(f) {
		var inPath = path.join(inputPath, f),
			outPath = path.join(outputPath, f);
			
		if (fs.existsSync(inPath)) {		
			fs.createReadStream( inPath ).pipe(fs.createWriteStream( outPath ));
		}
	});	
	
	// update info
	info.type = 'bible';
	info.divisions = [];
	info.divisionNames = [];
	info.sections = [];		

	
	// process books
	for (var i=0,il=BOOK_LIST.length; i<il; i++) {
		var dbsBookCode = BOOK_LIST[i],
			bookInfo = bibleData.getBookInfoByDbsCode(dbsBookCode),
			osisCode = bookInfo.osis,
			bookIndex = i,
			bookName = bibleData.getBookName(dbsBookCode, 'heb'),
			bookFilePath = path.join(inputPath, osisCode + '.xml');

		info.divisionNames.push(bookName);			
		info.divisions.push(dbsBookCode);			
			
		// read in file	
		var text = fs.readFileSync(bookFilePath, 'utf8'),
			separator = '<div type="book"',
			separatorStart = text.indexOf(separator),
			$book = $( text.substr(separatorStart) );
			
		console.log(osisCode, $book.find('chapter').length);
			
		$book.find('chapter').each(function(chapterIndex, chapterNode) {
			
			var $chapterNode = $(chapterNode),
				osisChapterCode = $chapterNode.attr('osisID'),
				osisChapterParts = osisChapterCode ? osisChapterCode.split('.') : [],
				chapterNumber = osisChapterParts.length > 1 ? osisChapterParts[1] : '',
				dbsChapterCode = dbsBookCode + chapterNumber,
				nextid = bibleData.getNextChapter(dbsChapterCode),
				previd = bibleData.getPrevChapter(dbsChapterCode);

			
			info.sections.push(dbsChapterCode);
			
			if (chapterNumber == '') {
				console.log('No chapter OSIS', $chapterNode[0].attributes["osisID"].value, $chapterNode.find('verse').length	);
				return;
				
			}
			
			
			var html = 
				'<!DOCTYPE html>' + 
				'<html><head><meta charset="UTF-8" /><title>' + chapter.id + '</title></head>' + 
				'<body>' + 
				' <div id="tnav"><span><a class="prev" href="' + previd + '.html">&#9664;</a><a class="home" href="../../../mobile.html#' + chapter.id + '">&#9776;</a><a class="next" href="' + nextid + '.html">&#9654;</a></span></div> ' +
					'<div class="section chapter ' + info['id'] + ' ' + chapter.id + ' ' + chapter.id.substring(0,2) + ' ' + info['lang'] + '" data-id="' + chapter.id + '" data-nextid="' + nextid + '" data-previd="' + previd + '" dir="' + info['dir'] + '" lang="' + info['lang'] + '">' + breakChar +
					chapter.html + breakChar + 
					'</div>' + breakChar +
				'</body>' + breakChar +
				'</html>'
			;
					
			// chapter number
			if (chapterNumber == 1) {
				html += '<div class="mt">' + bookName + '</div>' + breakChar;
			}
			html += '<div class="c">' + (dbsBookCode == 'PS' && info.lang == 'eng' ? 'Psalm ' : '') + chapterNumber + '</div>' + breakChar;
			//html += '<div class="p">';
			
			
			$chapterNode.find('verse').each(function(verseIndex, verseNode) {
				var $verseNode = $(verseNode),
					osisVerseCode = $verseNode.attr('osisID'),
					verseNumber = osisVerseCode.split('.')[2],
					dbsVerseCode = dbsChapterCode + '_' + verseNumber;
					
				// verse number
				html += '<span class="v-num v-' + verseNumber + '">' + verseNumber + '</span>';
				
				// open verse
				html += '<span class="v ' + dbsVerseCode + '" data-id="' + dbsVerseCode + '">';

				//console.log(dbsVerseCode, verseNode.childNodes.length);
					
				var textToIndex = '';
				for (var i=0, il=verseNode.childNodes.length; i<il; i++) {
					var n = verseNode.childNodes[i];
					
					//console.log(n.nodeName);					
					
					switch (n.nodeName.toLowerCase()) {
						// element
						case 'w':
							var $word = $(n),
								lemma = $word.attr('lemma'),
								morph = $word.attr('morph'),
								// TEMP: remove / from between words
								text = $word.html(),
								inlineWord = text.replace(/\//gi,''),
								indexedWordParts = text.replace(/[\u0591-\u05C7]/g,'').split('/'),
								indexedWord = indexedWordParts.length == 1 || indexedWordParts.length == 2 ? 
												indexedWordParts[0] : 
												indexedWordParts.length == 3 ? 
													indexedWordParts[1] : indexedWordParts.join('');
								
								strongs = 'H' + lemma.replace(/[^\d]+/gi, '');
								
							html += '<l s="' + strongs + '"' + (morph ? ' m="' + morph + '"' : '') + '>' + inlineWord + '</l>';
							
							// strip out all vowels and such
							textToIndex += indexedWord + ' ';													
							
							if (createIndex) {					
								verseIndexer.indexStrongs(lemmaIndexOutputPath, dbsVerseCode, strongs, lemmaIndexData, info.lang);
							}									
							
							break;
						// punctuation
						case 'seg':
							html += n.textContent;
							//textToIndex += n.nodeValue;						
						
							break;
						// text
						case '#text':
							html += n.nodeValue;
							textToIndex += n.nodeValue;						
						
							break;
							
					}
					
					
				}

				/*
				// words
				var textToIndex = '';
				$verseNode.find('w').each(function(wordIndex, wordNode) {
					var $word = $(wordNode),
						lemma = $word.attr('lemma'),
						morph = $word.attr('morph'),
						text = $word.html().replace('/','');
						
					var strongs = 'H' + lemma.replace(/\w\//gi, '');
						
					html += '<l s="' + strongs + '"' + (morph ? ' m="' + morph + '"' : '') + '>' + text + '</l> ';

					textToIndex += text + ' ';													
					
					if (createIndex) {					
						verseIndexer.indexStrongs(lemmaIndexOutputPath, dbsVerseCode, strongs, lemmaIndexData, info.lang);
					}		
					
				});
				*/
				
				if (createIndex) {					
					verseIndexer.indexVerse(indexOutputPath, dbsVerseCode, textToIndex, indexData, info.lang);
				}			
			
				// close verse
				html += '</span>' + breakChar;;
			
			});
			
			
			
			// close chapter
			html += '</div>';
					
			// write out!
			fs.writeFileSync( path.join(outputPath, dbsChapterCode + '.html'), html);
		});
		
	}
	
	// info
	fs.writeFileSync( path.join(outputPath, 'info.json'), JSON.stringify(info));
	
	// index!
	if (createIndex) {
		verseIndexer.createIndexFiles(indexOutputPath, indexData);
		
		if (!fs.existsSync(lemmaIndexOutputPath)) {
			fs.mkdirSync(lemmaIndexOutputPath);			
		}
		
		verseIndexer.createIndexFiles(lemmaIndexOutputPath, lemmaIndexData);
	}	
}

// hebrew morph: http://openscriptures.github.io/morphhb/parsing/HebrewMorphologyCodes.html
// https://github.com/openscriptures/morphhb/blob/master/wlc/Ruth.xml


module.exports = {
	generate: generate
}